name: NAS Container Update

on:
  # 1. Manual Trigger
  workflow_dispatch:
  
  # 2. Automatic Trigger
  push:
    branches:
      - main
    paths:
      - '**/docker-compose.yml'
      - '**/docker-compose.yaml'

concurrency:
  group: ${{ github.ref }}
  # cancel-in-progress: true # commenting out as causing PR's to cancel when running a few together

jobs:
  deploy:
    runs-on: [self-hosted, nas]
    steps:
      - name: Checkout Code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6
        with:
          fetch-depth: 2  # CRITICAL: Required to detect changed files

      - name: Determine Stacks to Update
        id: filter
        run: |
          # Initialize an empty list
          STACKS=""
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "üëâ Manual Trigger detected: Updating ALL stacks."
            STACKS=$(find . -name "docker-compose.y*ml")
          else
            echo "üëâ Push detected: analyzing changes..."
            # Get list of changed files in this commit
            CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
            
            # Extract unique directories that contain a docker-compose file
            # We filter the changed files to only include those inside stack folders
            STACKS=$(echo "$CHANGED_FILES" | grep "docker-compose" | xargs -L1 dirname | sort -u | xargs -I {} find {} -name "docker-compose.y*ml")
            
            if [ -z "$STACKS" ]; then
               echo "‚ö†Ô∏è No docker-compose files were modified. Nothing to update."
            else
               echo "üëâ Detected changes in the following stacks:"
               echo "$STACKS"
            fi
          fi
          
          # Save the list to the GITHUB_ENV so the next step can read it
          # We use a delimiter because the list has multiple lines
          {
            echo "STACK_LIST<<EOF"
            echo "$STACKS"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Deploy Stacks
        if: env.STACK_LIST != ''
        run: |
          echo "üöÄ Starting Deployment..."
          
          # Loop through the list of stacks we identified in the previous step
          echo "$STACK_LIST" | while IFS= read -r file; do
            [ -z "$file" ] && continue # Skip empty lines
            
            dir=$(dirname "$file")
            stack_name=$(basename "$dir")
            
            echo "---------------------------------------------------"
            echo "üìÇ Processing Stack: $stack_name"
            echo "---------------------------------------------------"
            
            cd "$dir"
            
            # 1. SECRET INJECTION
            TARGET_ENV="/volume2/FastSSD/docker/$stack_name/.env"
            
            if [ -f "$TARGET_ENV" ]; then
                echo "   üîë Found secrets on NAS! Injecting .env file..."
                cp "$TARGET_ENV" ./.env
            else
                echo "   üõ°Ô∏è Creating an empty .env file to satisfy compose requirements."
                touch ./.env
            fi
            
            # 2. SLEDGEHAMMER (Stop First)
            echo "   üõë Stopping old containers..."
            docker compose down --remove-orphans
            
            # 3. PULL
            echo "   ‚¨áÔ∏è Pulling latest images..."
            docker compose pull

            # 4. START
            echo "   üöÄ Starting new containers..."
            if ! docker compose up -d --remove-orphans; then
              echo "   ‚ùå ERROR: Failed to start $stack_name"
            else
              echo "   ‚úÖ Successfully deployed $stack_name"
            fi
            
            # Go back to root
            cd - > /dev/null
          done

      - name: Cleanup
        run: docker image prune -f
